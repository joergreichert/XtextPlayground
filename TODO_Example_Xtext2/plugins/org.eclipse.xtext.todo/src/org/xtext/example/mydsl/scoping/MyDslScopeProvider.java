/*
 * generated by Xtext
 */
package org.xtext.example.mydsl.scoping;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map.Entry;
import java.util.Set;

import org.eclipse.emf.common.util.TreeIterator;
import org.eclipse.emf.ecore.EClassifier;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.plugin.EcorePlugin;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider;
import org.xtext.example.mydsl.myDsl.Entity;
import org.xtext.example.mydsl.myDsl.FeatureReference;
import org.xtext.example.mydsl.myDsl.Referencable;
import org.xtext.example.mydsl.myDsl.Reference;
import org.xtext.example.mydsl.myDsl.ReferenceChain;
import org.xtext.example.mydsl.myDsl.ReferenceExpression;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
public class MyDslScopeProvider extends AbstractDeclarativeScopeProvider {

	public IScope scope_ReferenceChain_target(ReferenceChain chain,
			EReference ref) {
		ReferenceExpression source = chain.getSource();
		Referencable previous = null;
		if (source instanceof ReferenceChain) {
			ReferenceChain referenceChain = (ReferenceChain) source;
			previous = referenceChain.getTarget();
		} else if (source instanceof Reference) {
			Reference reference = (Reference) source;
			previous = reference.getElement();
		}
		IScope scope = IScope.NULLSCOPE;
		if (previous instanceof Entity) {
			Entity entity = (Entity) previous;
			scope = Scopes.scopeFor(entity.getFeatures());
		} else if (previous instanceof FeatureReference) {
			FeatureReference featureReference = (FeatureReference) previous;
			Referencable type = featureReference.getType();
			if (type instanceof Entity) {
				Entity entity = (Entity) type;
				scope = Scopes.scopeFor(entity.getFeatures());
			}
		}
		return scope;
	}

	protected IScope delegateGetScope(EObject context, EReference reference) {
		if (context instanceof FeatureReference && "mapsTo".equals(reference.getName())) {
			return scope_FeatureReference_mapsTo((FeatureReference) context, reference);
		}
		return super.delegateGetScope(context, reference);
	}

	// Uses EPackage Registry and loaded EObjects
	public IScope scope_FeatureReference_mapsTo(FeatureReference entity, EReference ref) {
		Set<Entry<String, Object>> packages = EPackage.Registry.INSTANCE
				.entrySet();
		List<EPackage> ePackages = getEPackages(packages);
		TreeIterator<EObject> contents;
		EObject o;
		Set<EClassifier> eClassifiers = new HashSet<EClassifier>();
		for (EPackage pack : ePackages) {
			contents = pack.eAllContents();
			while (contents.hasNext()) {
				o = contents.next();
				if (o instanceof EClassifier) {
					eClassifiers.add((EClassifier) o);
				}
			}
		}
		return Scopes.scopeFor(eClassifiers);
	}

	private List<EPackage> getEPackages(Set<Entry<String, Object>> packages) {
		List<EPackage> ePackages = new ArrayList<EPackage>();
		try {
			Object packageObj = null;
			EPackage.Descriptor ePackageDescriptor = null;
			EPackage ePackage = null;
			for (Entry<String, Object> entry : packages) {
				packageObj = entry.getValue();
				if (packageObj instanceof EPackage) {
					ePackages.add((EPackage) packageObj);
				} else if (packageObj instanceof EPackage.Descriptor) {
					ePackageDescriptor = (EPackage.Descriptor) packageObj;
					ePackage = ePackageDescriptor.getEPackage();
					if (ePackage != null) {
						ePackages.add(ePackage);
					}
				}
			}
			return ePackages;
		} catch (Exception e) {
			e.printStackTrace();
		}
		return ePackages;
	}
}
